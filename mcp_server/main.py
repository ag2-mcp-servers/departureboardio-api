# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T18:29:12+00:00



import argparse
import json
import os
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity
from fastapi import Path, Query
from pydantic import conint, constr

app = MCPProxy(
    contact={'x-twitter': 'departure_board'},
    description='The departureboard.io is a high performance API written in Golang. Its goal is to provide to main functions:<br><br> (1): A JSON API interface to the legacy National Rail SOAP API: Giving developers the ability to pull live information on departures, arrivals, and services from National Rail, without having to use the legacy SOAP API provided by National Rail. Information is still pulled directly from National Rail in the background, providing the same level of real-time data without the additional complexity of having to interact with SOAP. <br><br>(2): A JSON API interface for additional National Rail information: Giving developers the ability to pull a range of information about the Rail Network, via a JSON API interface. This is not an offering that National Rail currently provide, and is custom developed. Data is sourced from periodically updated XML documents, parsed, and provided for consumption via the departureboard.io API.<br><br>This API is completely free to use for non-commercial purposes. You can explore the various sections of the documentation using the links below.<br><br> For more information please see <a href="https://api.departureboard.io">https://api.departureboard.io</a>',
    title='departureboard.io API',
    version='2.0',
    servers=[
        {
            'description': 'V2 Production Server',
            'url': 'https://api.departureboard.io/api/v2.0',
        }
    ],
)


@app.get('/getArrivalsAndDeparturesByCRS/{CRS}', tags=['train_schedule_info'])
def get_arrivals_and_departures_by_c_r_s(
    c_r_s: constr(min_length=3, max_length=3) = Path(..., alias='CRS'),
    api_key: str = Query(..., alias='apiKey'),
    num_services: Optional[int] = Query(10, alias='numServices'),
    time_offset: Optional[conint(ge=-239, le=119)] = Query(0, alias='timeOffset'),
    time_window: Optional[conint(ge=0)] = Query(120, alias='timeWindow'),
    service_details: Optional[bool] = Query(True, alias='serviceDetails'),
    filter_station: Optional[str] = Query(None, alias='filterStation'),
    filter_type: Optional[str] = Query(None, alias='filterType'),
):
    """
    getArrivalsAndDeparturesByCRS is used to get a list of services arriving to and departing from a UK train station by the CRS (Computer Reservation System) code. This will typically return a list of train services, but will also return any replacement bus or ferry services that are in place.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/getArrivalsByCRS/{CRS}', tags=['train_schedule_info'])
def get_arrivals_by_c_r_s(
    c_r_s: constr(min_length=3, max_length=3) = Path(..., alias='CRS'),
    api_key: str = Query(..., alias='apiKey'),
    num_services: Optional[int] = Query(10, alias='numServices'),
    time_offset: Optional[conint(ge=-239, le=119)] = Query(0, alias='timeOffset'),
    time_window: Optional[conint(ge=0)] = Query(120, alias='timeWindow'),
    service_details: Optional[bool] = Query(True, alias='serviceDetails'),
    filter_station: Optional[str] = Query(None, alias='filterStation'),
):
    """
    getArrivalsByCRS is used to get a list of services arriving to a UK train station by the CRS (Computer Reservation System) code. This will typically return a list of train services, but will also return any replacement bus or ferry services that are in place.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/getDeparturesByCRS/{CRS}', tags=['train_schedule_info'])
def get_departures_by_c_r_s(
    c_r_s: constr(min_length=3, max_length=3) = Path(..., alias='CRS'),
    api_key: str = Query(..., alias='apiKey'),
    num_services: Optional[int] = Query(10, alias='numServices'),
    time_offset: Optional[conint(ge=-239, le=119)] = Query(0, alias='timeOffset'),
    time_window: Optional[conint(ge=0)] = Query(120, alias='timeWindow'),
    service_details: Optional[bool] = Query(True, alias='serviceDetails'),
    filter_station: Optional[str] = Query(None, alias='filterStation'),
):
    """
    getDeparturesByCRS is used to get a list of services departing from a UK train station by the CRS (Computer Reservation System) code. This will typically return a list of train services, but will also return any replacement bus or ferry services that are in place.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/getFastestDeparturesByCRS/{CRS}',
    tags=['train_schedule_info', 'fastest_train_retrieval'],
)
def get_fastest_departures_by_c_r_s(
    c_r_s: constr(min_length=3, max_length=3) = Path(..., alias='CRS'),
    api_key: str = Query(..., alias='apiKey'),
    filter_list: str = Query(..., alias='filterList'),
    time_offset: Optional[conint(ge=-239, le=119)] = Query(0, alias='timeOffset'),
    time_window: Optional[conint(ge=0)] = Query(120, alias='timeWindow'),
    service_details: Optional[bool] = Query(True, alias='serviceDetails'),
):
    """
    getFastestDeparturesByCRS is used to get the fastest next service running between two stations. Multiple destinations can be specified. This will typically return a single train service, but will also return a replacement bus or ferry service if in place.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get('/getNextDeparturesByCRS/{CRS}', tags=['train_schedule_info'])
def get_next_departures_by_c_r_s(
    c_r_s: constr(min_length=3, max_length=3) = Path(..., alias='CRS'),
    api_key: str = Query(..., alias='apiKey'),
    filter_list: str = Query(..., alias='filterList'),
    time_offset: Optional[conint(ge=-239, le=119)] = Query(0, alias='timeOffset'),
    time_window: Optional[conint(ge=0)] = Query(120, alias='timeWindow'),
    service_details: Optional[bool] = Query(True, alias='serviceDetails'),
):
    """
    getNextDeparturesByCRS is used to get the next service running between two stations. Multiple destinations can be specified. This will typically return a single train service, but will also return a replacement bus or ferry service if in place. This will return the next departures for each of the filterList stations specified. It may not return the fastest next service. To get the fastest next service use the getFastestDeparturesByCRS endpoint.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/getServiceDetailsByID/{serviceID}',
    tags=['train_schedule_info', 'specific_service_details'],
)
def get_service_details_by_i_d(
    service_i_d: str = Path(..., alias='serviceID'),
    api_key: str = Query(..., alias='apiKey'),
):
    """
    getServiceDetailsByID is used to get information on a service, by the Service ID. This will typically return a train service, but will also return a bus and ferry services. The Service ID must be provided in the serviceIDUrlSafe format that is provided in the response for Arrival and Departure Boards. A service ID is specific to a station, and can only be looked up for a short time after a train/bus/ferry arrives at, or departs from a station. This is a National Rail limitation.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
